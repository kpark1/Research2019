import os
import errno
import re
import sys


class GbtPacketMaker:
    '''
    This is a class to make GBT packets.
    '''
    def __init__(self, input_vmm_list, input_channel_list):
        '''
        Initializes GbtPacketMaker object.
        
        Parameters
        ----------
        input_vmm_list : list
            list of plane and vmm information  
        '''
        vmm_list, channel_list = zip(*sorted(zip(input_vmm_list, input_channel_list)))  # IMPT: sort the input vmm and channel pairs from smallest to largest
        self.vmm_list = list(vmm_list)
        self.channel_list = list(channel_list)

    @staticmethod
    def align(ls):          # align all elements in lists within lists
        '''
        Align all elements in lists within lists
        

        par list list: list to be aligned
        '''
        aligned = []
        for plane in ls:
            for vmm_num in plane:
                aligned.append(vmm_num)
        return aligned

    @staticmethod
    def chunky(ls, n):      # divide into lists of n elements
        while len(ls)%n != 0:
            ls.insert(0, 0)
        return [ls[i * n:(i + 1) * n] for i in range((len(ls) + n - 1)//n)]

    @staticmethod
    def read_chunks(ls):    # read a list of lists of four integers interpreting them as a binary number
        chunks_read = []    # e.g. [[1,1,0,1],[0,0,1,0]] would be translated into [13, 2]
        for each in ls:
            count = 3 # NEED TO BE CHANGED TO ACCOMMODATE FOR N'S; currently only works for converting into 4 elements
            num = 0
            for digit in each:
                num += digit * (2**count)
                count -= 1

            chunks_read.append(num)

        return chunks_read

    @staticmethod
    def to_hex(ls):         # convert a number into a hexadecimal string
        final = hex(0)
        for each in ls:
            final += hex(each)[2:]      # changes from 0xf to f

        final = final[3:]               # subtract the first three digits b/c other wise extra "0x0"
        return final

    @staticmethod
    def sorted_alphanumeric(data):      # sort in alphanumerical way
        convert = lambda text: int(text) if text.isdigit() else text.lower()
        alphanum_key = lambda key: [convert(c) for c in re.split('([0-9]+)', key)]
        return sorted(data, key=alphanum_key)

    @staticmethod
    def combine_gbt(dir_name, typ, num_fibers):
        file_ls = GbtPacketMaker.sorted_alphanumeric(os.listdir(dir_name))  # sort the files in the same directory
        if typ == "all":    #if combining all in the directory
            file_ls = [dir_name + file for file in file_ls]                       # add directory path
            with open('combined_%s' % dir_name[:-1], 'w') as out_file:
                for file in file_ls:
                    with open(file) as in_file:
                        out_file.write(in_file.read())

                fin_line = '00000001 01'
                out_file.write(fin_line)
                out_file.close()

        if typ == "pair":     # if individual packet pair

            ls = GbtPacketMaker.chunky(file_ls, num_fibers)
            directory = "combined_" + dir_name
            if not os.path.exists(os.path.dirname(directory)):
                try:
                    os.makedirs(os.path.dirname(directory))  # only creates a new directory if it doesn't exist already
                except OSError as exc:
                    if exc.errno != errno.EEXIST:
                        raise

            for j in range(len(ls[0])//2):
                if len(ls[0]) % 2!=0:
                    print("Some fibers don't have their pairs.")

                for i in range(len(ls)):
                    file_ls = [dir_name + file_temp for file_temp in ls[i][2*j:2*j + 2]]
                    print(file_ls)
                    with open(os.path.join(directory, file_ls[0].split("/")[1]), 'w') as out_file:
                        for file in file_ls:
                            with open(file) as in_file:
                                out_file.write(in_file.read())

                        fin_line = '00000001 01'
                        out_file.write(fin_line)
                        out_file.close()

    def align_vmm(self):
        # visualize aligned vmm of all planes
        vmm_each_plane = [[], [], [], [], [], [], [], []]  # separates into each plane

        for i in range(len(self.vmm_list)):
            vmm_str = str(self.vmm_list[i])                # convert into string
            plane_int = int(vmm_str[0])                    # extract plane info in int
            vmm_int = int(vmm_str[2])                      # extract vmm info in int
            vmm_each_plane[plane_int].append(vmm_int)      # make a list of vmm's by each plane
        # create empty vmm bin
        vmm_bin = []
        for i in range(4): # four planes (2 x planes 2 stereo - u and v - planes
            vmm_bin.append([0, 0, 0, 0, 0, 0, 0, 0])

        for i in range(len(vmm_each_plane)):
            for vmm in vmm_each_plane[i]:
                vmm_bin[i][-(vmm + 1)] = 1                 # CHANGE 1 TO "1" IF WANTS STRING

        vmm_bin.reverse()
        vmm_aligned = GbtPacketMaker.align(vmm_bin)
        return vmm_aligned

    def read_vmm(self): # Hit Map Creator
        vmm = GbtPacketMaker.align_vmm(self)
        vmm_chunks = GbtPacketMaker.chunky(vmm, 4)
        hit_map_almost = GbtPacketMaker.read_chunks(vmm_chunks)

        if len(hit_map_almost) > 8:                        # remove extra lists/empty lists filled with zero's
            hit_map_almost = hit_map_almost[len(vmm_chunks)-8:len(vmm_chunks)]
        if len(hit_map_almost) < 8:
            for n in range(8-len(hit_map_almost)):
                hit_map_almost.insert(0, 0)

        hit_map = GbtPacketMaker.to_hex(hit_map_almost)
        hit_map = hit_map.upper()
        return hit_map

    def read_channel(self):  # ART data Creator

        channel = []
        channel_ls = self.channel_list[::-1]            # same as reverse function (by slicing)

        for ch in channel_ls:
            six_digit = '{0:06b}'.format(ch)            # f'{channel:08b}' if python 3.6 or above
            channel.append(six_digit)

        channel_aligned = GbtPacketMaker.align(channel)

        new_channel = []
        for digit in channel_aligned:                   # change all binary digit to int
            new_channel.append(int(digit))

        channel_chunks = GbtPacketMaker.chunky(new_channel, 4)
        art_data_chunks = GbtPacketMaker.read_chunks(channel_chunks)
        art_data_almost = GbtPacketMaker.to_hex(art_data_chunks)
        art_data = art_data_almost.zfill(12).upper()
        return art_data

    def find_parity(self):
        ls = []
        for channel in self.channel_list:
            channel_bin = '{0: 04b}'.format(channel)
            count =0

            for i in range(len(channel_bin)):
                if channel_bin[i] == '1':
                    count += 1
            if count % 2 == 0:
                ls.append(1)
            if count % 2 != 0:
                ls.append(0)

        ls.reverse()    # reverse the order

        before_hex = GbtPacketMaker.chunky(ls, 4)
        chunks_read = GbtPacketMaker.read_chunks(before_hex)
        parity = GbtPacketMaker.to_hex(chunks_read).upper()
        return parity

    def make_gbt(self, BCID, fiber, directory_name, add_line, second_dir="none"):
        bcid_converted = hex(BCID)[2:].upper()
        if len(bcid_converted) > 3:          # Important
            print("BC %s is too large. Fix the pattern code to limit BC number maximum." %BCID)
            sys.exit()

        bcid_converted  = bcid_converted.zfill(3)
        header = "0000A" + bcid_converted  # e.g. "0000A00A" where "00A" is a bunch crossing id
        error = "00"
        tag = str(self.vmm_list) + str(self.channel_list)
        hit_map = str(GbtPacketMaker.read_vmm(self))
        parity = str(GbtPacketMaker.find_parity(self))
        if len(parity) != 2:
            parity = "0" +parity # IS THIS CORRECT TO INSERT IT IN FRONT INSTEAD OF BACK?
        art_data = str(GbtPacketMaker.read_channel(self))
        final = header + error + hit_map+ parity+ art_data
        # print("hit map = %s parity = %s art data = %s " %(hit_map, parity,art_data))

        add = str(fiber)   # e.g." 20"
        output_file = "GBT_packet_BC=%s_fiber=%s_%s" % (BCID, fiber, tag)
        if second_dir.lower() == "none":
            directory = "GBT_packet_dir_%s/" % directory_name
        else:
            directory = "GBT_packet_dir_%s_%s/" % (directory_name, second_dir)

        if not os.path.exists(os.path.dirname(directory+output_file)):
            try:
                os.makedirs(os.path.dirname(directory+output_file)) # only creates a new directory if it doesn't exist already
            except OSError as exc:
                if exc.errno != errno.EEXIST:
                    raise
        #else:
            #print("directory %s exists" %directory+output_file)

        f = open(directory + output_file, 'w')  # 'w' instead of 'a' : each time this is opened it overwrites the file
        if len(final) % 8 == 0:
            for i in range(int(len(final) // 8)):
                line = final[i * 8:(i + 1) * 8] + ' ' + add
                f.write(line)
                f.write("\n")

            if add_line == "yes":
                fin_line = '00000001 01' # do this while combining -> IF individual packet needs this, add this, but make sure to change other parts of the code that combines all GDP packets
                f.write(fin_line)
            f.close()
            print("gbt file named {} created".format(output_file))
        else:
            print("GBT for {} not created correctly. Check if BC number is larger than 4095.".format(output_file))
            print("Not created file content is %s" % final)

    @staticmethod
    def vertical_pattern(region, pairs, offset, bc_gap_region, bc_start, bc_gap_pl=0):
        if "lower" in region and offset in [0, 1, 2, 3]:        # e.g. offset = 2
            pass
        elif "upper" in region and offset in [4, 5, 6, 7]:     # e.g. offset = 4
            pass
        else:
            print("Wrong Region or offset")
            exit()

        channels = [offset + 8 * i for i in range(8)]
        print(channels)
        dir_name = 'vert_%s_%s_offset%s_bc_gap_%s_bc_start_%s_bc_gap_pl_%s' % (region, pairs, offset, bc_gap_region, bc_start, bc_gap_pl)
        path = "GBT_packet_dir_%s/" % dir_name
        second_dir_name = "second"
        path2 = "GBT_packet_dir_%s_%s/" % (dir_name, second_dir_name)
        k = 0
        for i in range(len(pairs)):
            bc = bc_start + k  # impt to place this here for the pair to have the symmetrical list of BC's
            for ch in channels:
                pl = [[],[],[],[]]
                for n in range(8):  # repeat as many as the number of vmm's in each region = 8 vmm's in one fiber
                    pl[0] = 0.0 + round(n * (10 ** (-1)), 1)
                    pl[1] = 1.0 + round(n * (10 ** (-1)), 1)
                    pl[2] = 2.0 + round(n * (10 ** (-1)), 1)
                    pl[3] = 3.0 + round(n * (10 ** (-1)), 1)
                    if bc < 4096:       # max number of bc is 4095
                        if bc_gap_pl == 0:
                            GbtPacketMaker(pl,[ch,ch,ch,ch]).make_gbt(bc, pairs[i], dir_name, "no")
                        else:
                            for j in range(4):
                                GbtPacketMaker([pl[j]],[ch]).make_gbt(bc+j, pairs[i], dir_name, "no")

                    else:
                        temp_bc = bc - 4095             # add a separate directory for BC that are too large
                        if bc_gap_pl == 0:
                            GbtPacketMaker(pl, [ch,ch,ch,ch]).make_gbt(temp_bc, pairs[i], dir_name, "no", second_dir_name)
                        else:
                            for j in range(4):
                                GbtPacketMaker([pl[j]],[ch]).make_gbt(temp_bc+j, pairs[i], dir_name, "no", second_dir_name)

                    bc += bc_start

            if i % 2 != 0:
                 k += bc_gap_region

        if "specific" in region:
            GbtPacketMaker.combine_gbt(path, "pair", len(pairs))
            print("Combined file created")
            if os.path.exists(os.path.dirname(path2)):
                GbtPacketMaker.combine_gbt(path2, "pair", len(pairs))
                print("Combined file 2 created")
        else:
            GbtPacketMaker.combine_gbt(path, "all", len(pairs))    # CHANGE TO "pair" if wanting to combine in gbt pairs not all produced
            print("Combined file created")
            if os.path.exists(os.path.dirname(path2)):
                GbtPacketMaker.combine_gbt(path2, "all", len(pairs)) # combine the second file as well
                print("Combined file 2 created")

    @staticmethod
    def horizontal_pattern(region, x_offset, x_vmm, x_ch_idx, pairs, input_uv_offset, uv_dir="none",  bc_gap_region=0, bc_start=32, bc_gap_pl=0):
        def make_hor():
            uv_offset= input_uv_offset
            if "diagonal" in region:
                if input_uv_offset == 0 or (uv_dir != "left" and uv_dir != "right"):
                    exit()
                if uv_dir == "right":
                    uv_offset = -1 * input_uv_offset

            if "lower" in region and x_offset in [0, 1, 2, 3]:  # e.g. offset = 2
                pass
            elif "upper" in region and x_offset in [4, 5, 6, 7]:  # e.g. offset = 4
                pass
            else:
                print("wrong region")
                exit()

            interval = 8
            channels = [x_offset + interval * i for i in range(8)] # interval = 8
            if x_vmm in [i for i in range(8)]:
                x_ch = x_vmm * 64 + channels[x_ch_idx]
            else:
                print("Your x_vmm = %s  or x_ch_num = %s are out of range. x_ch_num should from "
                          "be %s and x_vmm should be in a range of 0 to 7" % (x_vmm, x_ch_num, channels))
                exit()

            if x_ch <= 510 // 2:
                num = range(x_ch // interval + 1)
            else:
                num = range((512 - x_ch) // interval + 1)

            # add left and right channels and minus the duplicated center
            u_ch_ls = list(reversed([- uv_offset + x_ch - interval * i for i in num])) + \
                      [- uv_offset + x_ch + interval * i for i in num][1:]
            v_ch_ls = list(reversed([i+ 2 * uv_offset for i in u_ch_ls]))
            return x_ch, u_ch_ls, v_ch_ls

        x_ch, u_ch_ls, v_ch_ls = make_hor()
        dir_name = "hor_%s_ch%s_pair%s_%s_bc_gap_%s_bc_gap_pl_%s" % (region, x_ch, pairs, uv_dir, bc_start, bc_gap_pl)  # CHANGE THE DIR NAME
        path = "GBT_packet_dir_%s/" % dir_name
        second_dir_name = "second"
        path2 = "GBT_packet_dir_%s_%s/" % (dir_name, second_dir_name)
        k = 0
        for i in range(len(pairs)):
            bc = bc_start   + k
            pl = [[], [], [], []]           # [x0, x1, u0, v0]
            for n in range(len(u_ch_ls)):
                if pairs[i] in [20, 22, 24, 26, 28]:
                    ch = [x_ch % 64, x_ch % 64, u_ch_ls[n] % 64, v_ch_ls[n] % 64]
                    x0 = round((x_ch // 64) * .1, 1)
                    x1 = x0 + 1
                    u0 = round((u_ch_ls[n] // 64) * .1 + 2, 1)
                    v0 = round((v_ch_ls[n] // 64) * .1 + 3, 1)
                    pl = [x0, x1, u0, v0]
                elif pairs[i] in [21, 23, 25, 27, 29]:
                    ch = [u_ch_ls[n] % 64, v_ch_ls[n] % 64, x_ch % 64, x_ch % 64]
                    x0 = round((x_ch // 64) * .1 + 2, 1)
                    x1 = x0 + 1
                    u0 = round((u_ch_ls[n] // 64) * .1, 1)
                    v0 = round((v_ch_ls[n] // 64) * .1 + 1, 1)
                    pl = [u0, v0, x0, x1]

                if bc < 4096:
                    if bc_gap_pl == 0:
                        GbtPacketMaker(pl,ch).make_gbt(bc, pairs[i], dir_name, "no")
                    #print(bc, [x_ch, u_ch_ls[n], v_ch_ls[n]], [pl[0],pl[1],pl[2],pl[3]], [x_ch % 64, x_ch % 64, u_ch_ls[n] % 64, v_ch_ls[n] % 64])
                    else:
                        for j in range(4):
                            GbtPacketMaker([pl[j]],[ch[j]]).make_gbt(bc+j, pairs[i], dir_name, "no")

                else:
                    temp_bc = bc - 4095             # add a separate directory for BC that are too large
                    if bc_gap_pl == 0:
                        GbtPacketMaker(pl,ch).make_gbt(temp_bc, pairs[i], dir_name, "no", second_dir_name)
                    else:
                        for j in range(4):
                            GbtPacketMaker([pl[j]],[ch[j]]).make_gbt(temp_bc+j, pairs[i], dir_name, "no"), second_dir_name

                bc += bc_start

            if i % 2 != 0:
                k += bc_gap_region

        if "specific" in region:
            GbtPacketMaker.combine_gbt(path, "pair", len(pairs))
            print("Combined file created")
            if os.path.exists(os.path.dirname(path2)):
                GbtPacketMaker.combine_gbt(path2, "pair", len(pairs))
                print("Combined file 2 created")
        else:
            GbtPacketMaker.combine_gbt(path, "all", len(pairs))  # CHANGE TO "pair" if wanting to combine in gbt pairs not all produced
            print("Combined file created")
            if os.path.exists(os.path.dirname(path2)):
                GbtPacketMaker.combine_gbt(path2, "all", len(pairs))  # combine the second file as well
                print("Combined file 2 created")




#GbtPacketMaker([0.0, 0.4, 1.5, 2.6, 3.7],[1,2,4,8,13]).make_gbt(32, 20, "test","yes")
#GbtPacketMaker.vertical_pattern("upper", [20, 21], 4, 0, bc_start=96, bc_gap_pl=1)
#GbtPacketMaker.horizontal_pattern("upper", 4, 3, 7, [20, 21], 0,  bc_gap_pl=1)


# # # BELOW ARE THE UPPER :
# #[4, 5, 6, 7, 12, 13, 14, 15, 20, 21, 22, 23, 28, 29, 30, 31, 36, 37, 38, 39, 44, 45, 46, 47, 52, 53, 54, 55, 60, 61, 62, 63]
